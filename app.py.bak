from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from flask_mail import Mail, Message
from flask_migrate import Migrate
from datetime import datetime, timedelta
import pyotp
import bcrypt
from models import db, User, Policy, PolicyViolation, IPRestriction, LoginAttempt, UserGroup, PolicyVersion, PolicySchedule, Notification, Report, SystemActivity, PolicyGroupAssignment, UserPolicyAssignment, UserGroupMembership
from config import Config
import re
from functools import wraps
import random
import string
from sqlalchemy import func

app = Flask(__name__)
app.config.from_object(Config)

# Initialize extensions
db.init_app(app)
migrate = Migrate(app, db)
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'
mail = Mail(app)

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role != 'admin':
            flash('Access denied. Admin privileges required.', 'error')
            return redirect(url_for('dashboard'))
        return f(*args, **kwargs)
    return decorated_function

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

def send_otp_email(user, otp):
    msg = Message('Your OTP Code',
                  sender=app.config['MAIL_USERNAME'],
                  recipients=[user.email])
    msg.body = f'Your OTP code is: {otp}\nThis code will expire in 2 minutes.'
    mail.send(msg)

def check_password_strength(password):
    if len(password) < app.config['PASSWORD_MIN_LENGTH']:
        return False
    if app.config['PASSWORD_REQUIRE_UPPER'] and not re.search(r'[A-Z]', password):
        return False
    if app.config['PASSWORD_REQUIRE_LOWER'] and not re.search(r'[a-z]', password):
        return False
    if app.config['PASSWORD_REQUIRE_NUMBERS'] and not re.search(r'\d', password):
        return False
    if app.config['PASSWORD_REQUIRE_SPECIAL'] and not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False
    return True

def check_ip_restriction(ip_address):
    if not app.config['ALLOWED_IPS']:
        return True
    return ip_address in app.config['ALLOWED_IPS']

def check_time_restriction():
    now = datetime.now()
    if now.weekday() not in app.config['WORKING_DAYS']:
        return False
    if not (app.config['WORKING_HOURS_START'] <= now.hour < app.config['WORKING_HOURS_END']):
        return False
    return True

def check_policy_violations(user, action_type, details=None):
    """Check for policy violations based on the action type and user."""
    violations = []
    
    # Get all active policies
    active_policies = Policy.query.filter_by(is_active=True).all()
    
    for policy in active_policies:
        if policy.type == 'password' and action_type == 'password_change':
            # Check password policy violations
            if not check_password_strength(details['new_password']):
                violations.append({
                    'policy_id': policy.id,
                    'violation_type': 'password',
                    'details': 'Password does not meet complexity requirements'
                })
        
        elif policy.type == 'login' and action_type == 'login_attempt':
            # Check login policy violations
            if user.failed_login_attempts >= policy.settings.get('max_attempts', 3):
                violations.append({
                    'policy_id': policy.id,
                    'violation_type': 'login',
                    'details': f'Exceeded maximum login attempts ({policy.settings.get("max_attempts", 3)})'
                })
        
        elif policy.type == 'ip' and action_type == 'access_attempt':
            # Check IP restriction violations
            if request.remote_addr not in policy.settings.get('allowed_ips', []):
                violations.append({
                    'policy_id': policy.id,
                    'violation_type': 'ip',
                    'details': f'Access attempt from unauthorized IP: {request.remote_addr}'
                })
        
        elif policy.type == 'time' and action_type == 'access_attempt':
            # Check time-based access violations
            now = datetime.now()
            current_time = now.strftime('%H:%M')
            current_day = now.weekday() + 1  # Convert to 1-based weekday
            
            if current_time < policy.settings.get('working_hours_start', '09:00') or \
               current_time > policy.settings.get('working_hours_end', '17:00') or \
               current_day not in policy.settings.get('working_days', [1, 2, 3, 4, 5]):
                violations.append({
                    'policy_id': policy.id,
                    'violation_type': 'time',
                    'details': 'Access attempt outside allowed working hours'
                })
    
    return violations

def record_policy_violations(user, violations):
    """Record policy violations in the database."""
    for violation in violations:
        policy_violation = PolicyViolation(
            user_id=user.id,
            policy_id=violation['policy_id'],
            violation_type=violation['violation_type'],
            details=violation['details'],
            timestamp=datetime.utcnow()
        )
        db.session.add(policy_violation)
    
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        print(f"Error recording policy violations: {str(e)}")

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        ip_address = request.remote_addr
        
        user = User.query.filter_by(username=username).first()
        
        # Check for policy violations before proceeding
        if user:
            violations = check_policy_violations(user, 'access_attempt')
            if violations:
                record_policy_violations(user, violations)
                flash('Access denied due to policy violations.', 'error')
                return redirect(url_for('login'))
            
            if user.failed_login_attempts >= app.config['MAX_LOGIN_ATTEMPTS']:
                violations = check_policy_violations(user, 'login_attempt')
                if violations:
                    record_policy_violations(user, violations)
                flash('Account locked due to too many failed attempts.', 'error')
                return redirect(url_for('login'))
        
        if user and bcrypt.checkpw(password.encode('utf-8'), user.password_hash):
            if user.failed_login_attempts >= app.config['MAX_LOGIN_ATTEMPTS']:
                flash('Account locked due to too many failed attempts.', 'error')
                return redirect(url_for('login'))
            
            otp = user.get_otp()
            send_otp_email(user, otp)
            return redirect(url_for('verify_otp', user_id=user.id))
        else:
            if user:
                user.failed_login_attempts += 1
                violations = check_policy_violations(user, 'login_attempt')
                if violations:
                    record_policy_violations(user, violations)
                db.session.commit()
            flash('Invalid username or password', 'error')
            return redirect(url_for('login'))
    
    return render_template('login.html')

@app.route('/verify-otp/<int:user_id>', methods=['GET', 'POST'])
def verify_otp(user_id):
    user = User.query.get_or_404(user_id)
    if request.method == 'POST':
        otp = request.form.get('otp')
        
        # Debug logging
        print(f"User OTP Secret: {user.otp_secret}")
        print(f"Current OTP: {user.get_otp()}")
        print(f"Submitted OTP: {otp}")
        print(f"Verification Result: {user.verify_otp(otp)}")
        
        if user.verify_otp(otp):
            login_user(user)
            user.failed_login_attempts = 0
            user.last_login = datetime.utcnow()
            db.session.commit()
            return redirect(url_for('dashboard'))
        else:
            flash('Invalid OTP. Please make sure to enter the code exactly as shown in your email.', 'error')
            print("Note: OTPs change every 30 seconds. Make sure you're entering the most recent code.")
    return render_template('verify_otp.html', user=user)

@app.route('/dashboard')
@login_required
def dashboard():
    return render_template('dashboard.html')

@app.route('/admin/users')
@login_required
@admin_required
def admin_users():
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.headers.get('Accept') == 'application/json':
        users = User.query.all()
        return jsonify({
            'success': True,
            'users': [{
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'role': user.role,
                'is_active': user.is_active
            } for user in users]
        })
    return render_template('admin/users.html', users=User.query.all())

@app.route('/admin/users/<int:user_id>', methods=['PUT', 'DELETE', 'GET'])
@login_required
@admin_required
def manage_user(user_id):
    user = User.query.get_or_404(user_id)
    
    if request.method == 'DELETE':
        try:
            db.session.delete(user)
            db.session.commit()
            return jsonify({'message': 'User deleted successfully'})
        except Exception as e:
            db.session.rollback()
            return jsonify({'error': str(e)}), 500
        
    elif request.method == 'PUT':
        try:
            # Get form data instead of JSON
            username = request.form.get('username')
            email = request.form.get('email')
            password = request.form.get('password')
            role = request.form.get('role')
            is_active = request.form.get('is_active') == 'on'
            
            # Update username if changed
            if username and username != user.username:
                if User.query.filter_by(username=username).first():
                    return jsonify({'success': False, 'error': 'Username already taken'}), 400
                user.username = username
                
            # Update email if changed
            if email and email != user.email:
                if User.query.filter_by(email=email).first():
                    return jsonify({'success': False, 'error': 'Email already registered'}), 400
                user.email = email
                
            # Update password if provided
            if password:
                hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
                user.password_hash = hashed_password
            
            # Update role
            if role:
                user.role = role
            
            # Update active status
            user.is_active = is_active
            
            db.session.commit()
            
            # Log the activity
            activity = SystemActivity(
                user_id=current_user.id,
                action='update_user',
                details=f'Updated user: {user.username}'
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({'success': True, 'message': 'User updated successfully'})
        except Exception as e:
            db.session.rollback()
            print(f"Error updating user: {str(e)}")  # Add debug logging
            return jsonify({'success': False, 'error': str(e)}), 500

    elif request.method == 'GET':
        try:
            return jsonify({
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'role': user.role,
                'is_active': user.is_active
            })
        except Exception as e:
            app.logger.error(f"Error fetching user {user_id}: {str(e)}")
            return jsonify({'error': str(e)}), 500

@app.route('/admin/policies')
@login_required
def admin_policies():
    if current_user.role != 'admin':
        flash('Access denied', 'error')
        return redirect(url_for('dashboard'))
    policies = Policy.query.all()
    users = User.query.all()
    groups = UserGroup.query.all()
    return render_template('admin/policies.html', policies=policies, users=users, groups=groups)

@app.route('/admin/violations')
@login_required
@admin_required
def admin_violations():
    violations = PolicyViolation.query.order_by(PolicyViolation.timestamp.desc()).all()
    return render_template('admin/violations.html', violations=violations)

@app.route('/admin/violations/<int:violation_id>')
@login_required
@admin_required
def get_violation_details(violation_id):
    violation = PolicyViolation.query.get_or_404(violation_id)
    return jsonify({
        'id': violation.id,
        'timestamp': violation.timestamp.isoformat(),
        'user': {'username': violation.user.username},
        'policy': {'name': violation.policy.name},
        'violation_type': violation.violation_type,
        'details': violation.details,
        'is_resolved': violation.is_resolved,
        'resolved_at': violation.resolved_at.isoformat() if violation.resolved_at else None
    })

@app.route('/admin/violations/<int:violation_id>/resolve', methods=['POST'])
@login_required
@admin_required
def resolve_violation(violation_id):
    violation = PolicyViolation.query.get_or_404(violation_id)
    violation.is_resolved = True
    violation.resolved_by_id = current_user.id
    violation.resolved_at = datetime.utcnow()
    db.session.commit()
    return jsonify({'success': True})

@app.route('/admin/violations/export')
@login_required
@admin_required
def export_violations():
    violations = PolicyViolation.query.order_by(PolicyViolation.timestamp.desc()).all()
    # Implementation for exporting violations to CSV/Excel
    return "Export functionality to be implemented"

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))

@app.route('/admin/groups')
@login_required
@admin_required
def admin_groups():
    groups = UserGroup.query.all()
    return render_template('admin/groups.html', groups=groups)

@app.route('/admin/groups', methods=['POST'])
@login_required
@admin_required
def create_group():
    try:
        data = request.form
        group = UserGroup(
            name=data['name'],
            description=data.get('description')
        )
        db.session.add(group)
        db.session.commit()
        return jsonify({'message': 'Group created successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/groups/<int:group_id>', methods=['PUT'])
@login_required
@admin_required
def update_group(group_id):
    try:
        group = UserGroup.query.get_or_404(group_id)
        data = request.get_json()
        group.name = data.get('name', group.name)
        group.description = data.get('description', group.description)
        db.session.commit()
        return jsonify({'message': 'Group updated successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/groups/<int:group_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_group(group_id):
    try:
        group = UserGroup.query.get_or_404(group_id)
        db.session.delete(group)
        db.session.commit()
        return jsonify({'message': 'Group deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>/versions')
@login_required
@admin_required
def policy_versions(policy_id):
    policy = Policy.query.get_or_404(policy_id)
    versions = PolicyVersion.query.filter_by(policy_id=policy_id).order_by(PolicyVersion.version_number.desc()).all()
    return render_template('admin/policy_versions.html', policy=policy, versions=versions)

@app.route('/admin/policies/<int:policy_id>/versions', methods=['POST'])
@login_required
@admin_required
def create_policy_version(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        data = request.form
        
        # Get the latest version number
        latest_version = PolicyVersion.query.filter_by(policy_id=policy_id).order_by(PolicyVersion.version_number.desc()).first()
        version_number = (latest_version.version_number + 1) if latest_version else 1
        
        version = PolicyVersion(
            policy_id=policy_id,
            version_number=version_number,
            name=data['name'],
            description=data.get('description'),
            settings=data.get('settings'),
            created_by_id=current_user.id
        )
        
        db.session.add(version)
        db.session.commit()
        return jsonify({'message': 'Policy version created successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>/versions/<int:version_id>/restore', methods=['POST'])
@login_required
@admin_required
def restore_policy_version(policy_id, version_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        version = PolicyVersion.query.get_or_404(version_id)
        
        # Restore policy settings from version
        policy.name = version.name
        policy.description = version.description
        policy.settings = version.settings
        
        db.session.commit()
        return jsonify({'message': 'Policy version restored successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>/schedules')
@login_required
@admin_required
def policy_schedules(policy_id):
    policy = Policy.query.get_or_404(policy_id)
    schedules = PolicySchedule.query.filter_by(policy_id=policy_id).all()
    return render_template('admin/policy_schedules.html', policy=policy, schedules=schedules)

@app.route('/admin/policies/<int:policy_id>/schedules', methods=['POST'])
@login_required
@admin_required
def create_policy_schedule(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        data = request.form
        
        schedule = PolicySchedule(
            policy_id=policy_id,
            start_time=datetime.strptime(data['start_time'], '%Y-%m-%dT%H:%M'),
            end_time=datetime.strptime(data['end_time'], '%Y-%m-%dT%H:%M'),
            is_active=True,
            created_by_id=current_user.id
        )
        
        db.session.add(schedule)
        db.session.commit()
        return jsonify({'message': 'Policy schedule created successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>/schedules/<int:schedule_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_policy_schedule(policy_id, schedule_id):
    try:
        schedule = PolicySchedule.query.get_or_404(schedule_id)
        db.session.delete(schedule)
        db.session.commit()
        return jsonify({'message': 'Policy schedule deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/notifications')
@login_required
def notifications():
    notifications = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).all()
    return render_template('notifications.html', notifications=notifications)

@app.route('/notifications/<int:notification_id>/read', methods=['POST'])
@login_required
def mark_notification_read(notification_id):
    try:
        notification = Notification.query.get_or_404(notification_id)
        if notification.user_id != current_user.id:
            return jsonify({'error': 'Unauthorized'}), 403
            
        notification.is_read = True
        notification.read_at = datetime.utcnow()
        db.session.commit()
        return jsonify({'message': 'Notification marked as read'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/notifications/read-all', methods=['POST'])
@login_required
def mark_all_notifications_read():
    try:
        Notification.query.filter_by(user_id=current_user.id, is_read=False).update({
            'is_read': True,
            'read_at': datetime.utcnow()
        })
        db.session.commit()
        return jsonify({'message': 'All notifications marked as read'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/reports')
@login_required
@admin_required
def admin_reports():
    reports = Report.query.order_by(Report.created_at.desc()).all()
    return render_template('admin/reports.html', reports=reports)

@app.route('/admin/reports', methods=['POST'])
@login_required
@admin_required
def create_report():
    try:
        data = request.get_json()
        name = data.get('name')
        report_type = data.get('type')
        parameters = data.get('parameters', {})
        schedule = data.get('schedule')

        # Validate required fields
        if not name or not report_type:
            return jsonify({'success': False, 'error': 'Name and type are required'}), 400

        # Validate report type
        if report_type not in ['violation', 'compliance', 'audit']:
            return jsonify({'success': False, 'error': 'Invalid report type'}), 400

        # Validate parameters based on report type
        if report_type == 'violation':
            if 'start_date' in parameters:
                try:
                    datetime.strptime(parameters['start_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid start date format. Use YYYY-MM-DD'}), 400
            if 'end_date' in parameters:
                try:
                    datetime.strptime(parameters['end_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid end date format. Use YYYY-MM-DD'}), 400
            if 'status' in parameters and parameters['status'] not in ['open', 'resolved', 'closed']:
                return jsonify({'success': False, 'error': 'Invalid status. Must be open, resolved, or closed'}), 400
            if 'policy_id' in parameters:
                try:
                    policy_id = int(parameters['policy_id'])
                    if not Policy.query.get(policy_id):
                        return jsonify({'success': False, 'error': 'Invalid policy ID'}), 400
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid policy ID format'}), 400

        elif report_type == 'compliance':
            if 'policy_type' in parameters and parameters['policy_type'] not in ['access', 'security', 'data']:
                return jsonify({'success': False, 'error': 'Invalid policy type'}), 400
            if 'is_active' in parameters:
                if not isinstance(parameters['is_active'], bool):
                    return jsonify({'success': False, 'error': 'is_active must be a boolean'}), 400

        elif report_type == 'audit':
            if 'start_date' in parameters:
                try:
                    datetime.strptime(parameters['start_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid start date format. Use YYYY-MM-DD'}), 400
            if 'end_date' in parameters:
                try:
                    datetime.strptime(parameters['end_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid end date format. Use YYYY-MM-DD'}), 400
            if 'action' in parameters and parameters['action'] not in ['create', 'update', 'delete', 'login', 'logout']:
                return jsonify({'success': False, 'error': 'Invalid action type'}), 400
            if 'user_id' in parameters:
                try:
                    user_id = int(parameters['user_id'])
                    if not User.query.get(user_id):
                        return jsonify({'success': False, 'error': 'Invalid user ID'}), 400
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid user ID format'}), 400

        # Create the report
        report = Report(
            name=name,
            type=report_type,
            parameters=parameters,
            schedule=schedule,
            created_by_id=current_user.id,
            is_active=True
        )
        db.session.add(report)
        db.session.commit()

        return jsonify({
            'success': True,
            'message': 'Report created successfully',
            'report': {
                'id': report.id,
                'name': report.name,
                'type': report.type,
                'schedule': report.schedule,
                'parameters': report.parameters,
                'is_active': report.is_active,
                'created_at': report.created_at.strftime('%Y-%m-%d %H:%M:%S')
            }
        })

    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error creating report: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/audit-logs')
@login_required
@admin_required
def admin_audit_logs():
    activities = SystemActivity.query.order_by(SystemActivity.timestamp.desc()).all()
    return render_template('admin/audit_logs.html', activities=activities)

# Add new routes for dashboard features
@app.route('/admin/roles')
@login_required
@admin_required
def admin_roles():
    return render_template('admin/roles.html')

@app.route('/admin/audit_trail')
@login_required
@admin_required
def admin_audit_trail():
    return render_template('admin/audit_trail.html')

@app.route('/admin/export_data')
@login_required
@admin_required
def admin_export_data():
    return render_template('admin/export_data.html')

@app.route('/admin/notifications')
@login_required
@admin_required
def admin_notifications():
    return render_template('admin/notifications.html')

@app.route('/admin/alerts')
@login_required
@admin_required
def admin_alerts():
    return render_template('admin/alerts.html')

@app.route('/admin/monitoring')
@login_required
@admin_required
def admin_monitoring():
    return render_template('admin/monitoring.html')

@app.route('/admin/policies', methods=['POST'])
@login_required
@admin_required
def create_policy():
    try:
        data = request.form
        
        # Create new policy
        policy = Policy(
            name=data['name'],
            type=data['type'],
            description=data['description'],
            is_active=True,
            settings={
                'require_upper': data.get('require_upper') == 'on',
                'require_lower': data.get('require_lower') == 'on',
                'require_numbers': data.get('require_numbers') == 'on',
                'require_special': data.get('require_special') == 'on',
                'min_length': int(data.get('min_length', 8)),
                'max_attempts': int(data.get('max_attempts', 3)),
                'lockout_time': int(data.get('lockout_time', 30)),
                'allowed_ips': [ip.strip() for ip in data.get('allowed_ips', '').split('\n') if ip.strip()],
                'working_hours_start': data.get('working_hours_start', '09:00'),
                'working_hours_end': data.get('working_hours_end', '17:00'),
                'working_days': [int(day) for day in data.getlist('working_days') if day.isdigit()]
            }
        )
        
        db.session.add(policy)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Policy created successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>', methods=['GET'])
@login_required
@admin_required
def get_policy(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        return jsonify({
            'success': True,
            'policy': {
                'id': policy.id,
                'name': policy.name,
                'type': policy.type,
                'description': policy.description,
                'is_active': policy.is_active,
                'settings': policy.settings or {}
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>', methods=['PUT'])
@login_required
@admin_required
def update_policy(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        
        # Get data based on content type
        if request.is_json:
            data = request.get_json()
        else:
            data = request.form.to_dict()
            # Handle working_days separately for form data
            if 'working_days' in request.form:
                data['working_days'] = request.form.getlist('working_days')
        
        # Update policy fields
        policy.name = data.get('name', policy.name)
        policy.type = data.get('type', policy.type)
        policy.description = data.get('description', policy.description)
        policy.is_active = data.get('is_active', '1') == '1'
        
        # Update settings based on policy type
        settings = {}
        
        if policy.type == 'password':
            settings = {
            'require_upper': data.get('require_upper') == 'on',
            'require_lower': data.get('require_lower') == 'on',
            'require_numbers': data.get('require_numbers') == 'on',
            'require_special': data.get('require_special') == 'on',
                'min_length': int(data.get('min_length', 8))
            }
        elif policy.type == 'login':
            settings = {
            'max_attempts': int(data.get('max_attempts', 3)),
                'lockout_time': int(data.get('lockout_time', 30))
            }
        elif policy.type == 'ip':
            settings = {
                'allowed_ips': [ip.strip() for ip in data.get('allowed_ips', '').split('\n') if ip.strip()]
            }
        elif policy.type == 'time':
            settings = {
            'working_hours_start': data.get('working_hours_start', '09:00'),
            'working_hours_end': data.get('working_hours_end', '17:00'),
                'working_days': [int(day) for day in data.get('working_days', []) if day]
        }
        
        policy.settings = settings
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Policy updated successfully'})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating policy: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/policies/<int:policy_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_policy(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        db.session.delete(policy)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Policy deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/change-password', methods=['POST'])
@login_required
def change_password():
    try:
        current_password = request.form.get('current_password')
        new_password = request.form.get('new_password')
        confirm_password = request.form.get('confirm_password')
        
        if not bcrypt.checkpw(current_password.encode('utf-8'), current_user.password_hash):
            return jsonify({'error': 'Current password is incorrect'}), 400
            
        if new_password != confirm_password:
            return jsonify({'error': 'New passwords do not match'}), 400
        
        # Check for password policy violations
        violations = check_policy_violations(current_user, 'password_change', {
            'new_password': new_password
        })
        
        if violations:
            record_policy_violations(current_user, violations)
            return jsonify({'error': 'New password violates password policy'}), 400
        
        # Update password
        current_user.password_hash = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt())
        db.session.commit()
        
        return jsonify({'message': 'Password updated successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/admin/policies/<int:policy_id>/assign', methods=['POST'])
@login_required
@admin_required
def assign_policy(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        data = request.get_json()
        
        if 'group_id' in data:
            # Assign policy to group
            group = UserGroup.query.get_or_404(data['group_id'])
            assignment = PolicyGroupAssignment(
                policy_id=policy_id,
                group_id=group.id,
                assigned_by_id=current_user.id
            )
            db.session.add(assignment)
            db.session.commit()
            return jsonify({'success': True, 'message': f'Policy assigned to group {group.name} successfully'})
            
        elif 'user_id' in data:
            # Assign policy to user
            user = User.query.get_or_404(data['user_id'])
            # Create a new UserPolicyAssignment record
            assignment = UserPolicyAssignment(
                user_id=user.id,
                policy_id=policy_id,
                assigned_by_id=current_user.id
            )
            db.session.add(assignment)
            db.session.commit()
            return jsonify({'success': True, 'message': f'Policy assigned to user {user.username} successfully'})
            
        return jsonify({'success': False, 'error': 'No group_id or user_id provided'}), 400
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error assigning policy: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/policies/<int:policy_id>/unassign', methods=['POST'])
@login_required
@admin_required
def unassign_policy(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        data = request.get_json()
        
        if 'group_id' in data:
            # Remove policy from group
            assignment = PolicyGroupAssignment.query.filter_by(
                policy_id=policy_id,
                group_id=data['group_id']
            ).first_or_404()
            db.session.delete(assignment)
            db.session.commit()
            return jsonify({'success': True, 'message': 'Policy unassigned from group successfully'})
            
        elif 'user_id' in data:
            # Remove policy from user
            assignment = UserPolicyAssignment.query.filter_by(
                user_id=data['user_id'],
                policy_id=policy_id
            ).first_or_404()
            db.session.delete(assignment)
            db.session.commit()
            return jsonify({'success': True, 'message': 'Policy unassigned from user successfully'})
            
        return jsonify({'success': False, 'error': 'No group_id or user_id provided'}), 400
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error unassigning policy: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/user-groups')
@login_required
@admin_required
def admin_user_groups():
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.headers.get('Accept') == 'application/json':
        groups = UserGroup.query.all()
        return jsonify({
            'success': True,
            'groups': [{
            'id': group.id,
            'name': group.name,
            'description': group.description
            } for group in groups]
        })
    return render_template('admin/user_groups.html', groups=UserGroup.query.all())

@app.route('/admin/user-groups', methods=['POST'])
@login_required
@admin_required
def create_user_group():
    try:
        data = request.form
        group = UserGroup(
            name=data['name'],
            description=data.get('description')
        )
        db.session.add(group)
        db.session.commit()
        
        # Log the activity
        activity = SystemActivity(
            user_id=current_user.id,
            action='create_group',
            details=f'Created new group: {group.name}'
        )
        db.session.add(activity)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Group created successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/user-groups/<int:group_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_user_group(group_id):
    try:
        group = UserGroup.query.get_or_404(group_id)
        group_name = group.name
        db.session.delete(group)
        db.session.commit()
        
        # Log the activity
        activity = SystemActivity(
            user_id=current_user.id,
            action='delete_group',
            details=f'Deleted group: {group_name}'
        )
        db.session.add(activity)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Group deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/user-groups/<int:group_id>', methods=['GET'])
@admin_required
def get_group(group_id):
    try:
        group = UserGroup.query.get_or_404(group_id)
        return jsonify({
            'success': True,
            'group': {
                'id': group.id,
                'name': group.name,
                'description': group.description,
                'users': [{'id': user.id, 'username': user.username} for user in group.users]
            }
        })
    except Exception as e:
        app.logger.error(f"Error fetching group: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/admin/user-groups/<int:group_id>/assign', methods=['POST'])
@login_required
@admin_required
def assign_user_to_group(group_id):
    try:
        app.logger.debug(f"Assigning user to group {group_id}")
        data = request.get_json()
        user_id = data.get('user_id')
        
        if not user_id:
            return jsonify({
                'success': False,
                'error': 'User ID is required'
            }), 400
            
        # Get the group and user
        group = UserGroup.query.get_or_404(group_id)
        user = User.query.get_or_404(user_id)
        
        app.logger.debug(f"Found group: {group.name}, user: {user.username}")
        
        # Check if user is already in the group
        if user in group.users:
            return jsonify({
                'success': False,
                'error': 'User is already in this group'
            }), 400
            
        # Add user to group
        group.users.append(user)
        db.session.commit()
        
        app.logger.debug(f"Successfully added user {user.username} to group {group.name}")
        
        return jsonify({
            'success': True,
            'message': f'User {user.username} added to group {group.name}'
        })
    except Exception as e:
        app.logger.error(f"Error assigning user to group: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/user-groups/<int:group_id>/unassign', methods=['POST'])
@login_required
@admin_required
def unassign_user_from_group_by_id(group_id):
    try:
        app.logger.debug(f"Unassigning user from group {group_id}")
        data = request.get_json()
        user_id = data.get('user_id')
        
        if not user_id:
            return jsonify({
                'success': False,
                'error': 'User ID is required'
            }), 400
            
        # Get the group and user
        group = UserGroup.query.get_or_404(group_id)
        user = User.query.get_or_404(user_id)
        
        app.logger.debug(f"Found group: {group.name}, user: {user.username}")
        
        # Check if user is in the group
        if user not in group.users:
            return jsonify({
                'success': False,
                'error': 'User is not in this group'
            }), 400
            
        # Remove user from group
        group.users.remove(user)
        db.session.commit()
        
        app.logger.debug(f"Successfully removed user {user.username} from group {group.name}")
        
        return jsonify({
            'success': True,
            'message': f'User {user.username} removed from group {group.name}'
        })
    except Exception as e:
        app.logger.error(f"Error unassigning user from group: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/reports/<int:report_id>/run', methods=['POST'])
@login_required
@admin_required
def run_report(report_id):
    try:
        report = Report.query.get_or_404(report_id)
        
        # Generate report based on type and parameters
        if report.type == 'violation':
            data = generate_violation_report(report.parameters)
        elif report.type == 'compliance':
            data = generate_compliance_report(report.parameters)
        elif report.type == 'audit':
            data = generate_audit_report(report.parameters)
        else:
            return jsonify({'success': False, 'error': 'Invalid report type'}), 400
            
        # Add report name to the data
        data['name'] = report.name
            
        # Update last run time
        report.last_run = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'data': data
        })
    except Exception as e:
        app.logger.error(f"Error running report: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

def generate_violation_report(parameters):
    try:
        query = PolicyViolation.query.join(Policy).join(User)
        
        # Apply filters from parameters
        if parameters:
            if 'start_date' in parameters:
                query = query.filter(PolicyViolation.timestamp >= datetime.strptime(parameters['start_date'], '%Y-%m-%d'))
            if 'end_date' in parameters:
                query = query.filter(PolicyViolation.timestamp <= datetime.strptime(parameters['end_date'], '%Y-%m-%d'))
            if 'status' in parameters:
                query = query.filter(PolicyViolation.status == parameters['status'])
            if 'policy_id' in parameters:
                query = query.filter(PolicyViolation.policy_id == parameters['policy_id'])
        
        violations = query.order_by(PolicyViolation.timestamp.desc()).all()
        
        return {
            'type': 'violation',
            'total_violations': len(violations),
            'violations': [{
                'id': v.id,
                'policy_id': v.policy_id,
                'policy_name': v.policy.name if v.policy else 'N/A',
                'user_id': v.user_id,
                'username': v.user.username if v.user else 'N/A',
                'timestamp': v.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
                'status': v.status,
                'details': v.details
            } for v in violations]
        }
    except Exception as e:
        app.logger.error(f"Error generating violation report: {str(e)}")
        raise

def generate_compliance_report(parameters):
    try:
        query = Policy.query
        
        # Apply filters from parameters
        if parameters:
            if 'policy_type' in parameters:
                query = query.filter(Policy.type == parameters['policy_type'])
            if 'is_active' in parameters:
                query = query.filter(Policy.is_active == parameters['is_active'])
        
        policies = query.all()
        
        return {
            'type': 'compliance',
            'total_policies': len(policies),
            'policies': [{
                'id': p.id,
                'name': p.name,
                'type': p.type,
                'is_active': p.is_active,
                'total_assignments': len(p.user_assignments) + len(p.groups)
            } for p in policies]
        }
    except Exception as e:
        app.logger.error(f"Error generating compliance report: {str(e)}")
        raise

def generate_audit_report(parameters):
    try:
        query = SystemActivity.query.join(User)
        
        # Apply filters from parameters
        if parameters:
            if 'start_date' in parameters:
                query = query.filter(SystemActivity.timestamp >= datetime.strptime(parameters['start_date'], '%Y-%m-%d'))
            if 'end_date' in parameters:
                query = query.filter(SystemActivity.timestamp <= datetime.strptime(parameters['end_date'], '%Y-%m-%d'))
            if 'action' in parameters:
                query = query.filter(SystemActivity.action == parameters['action'])
            if 'user_id' in parameters:
                query = query.filter(SystemActivity.user_id == parameters['user_id'])
        
        activities = query.order_by(SystemActivity.timestamp.desc()).all()
        
        return {
            'type': 'audit',
            'total_activities': len(activities),
            'activities': [{
                'id': a.id,
                'user_id': a.user_id,
                'username': a.user.username if a.user else 'N/A',
                'action': a.action,
                'timestamp': a.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
                'details': a.details
            } for a in activities]
        }
    except Exception as e:
        app.logger.error(f"Error generating audit report: {str(e)}")
        raise

@app.route('/admin/dashboard')
@login_required
@admin_required
def admin_dashboard():
    try:
        # Get basic statistics
        total_users = User.query.count()
        total_policies = Policy.query.count()
        total_violations = PolicyViolation.query.count()
        total_groups = UserGroup.query.count()
        
        # Get additional statistics
        active_users = User.query.filter_by(is_active=True).count()
        assigned_policies = UserPolicyAssignment.query.count()
        pending_violations = PolicyViolation.query.filter_by(is_resolved=False).count()
        
        # Calculate total group members using the UserGroupMembership model
        total_group_members = db.session.query(func.count()).select_from(UserGroupMembership).scalar() or 0
        
        # Get last backup time (you'll need to implement this based on your backup system)
        last_backup = "2 hours ago"  # Placeholder, implement actual backup tracking
        
        # Get recent activities
        recent_activities = SystemActivity.query.order_by(SystemActivity.timestamp.desc()).limit(5).all()
        
        return render_template('admin/dashboard.html',
                             total_users=total_users,
                             active_users=active_users,
                             total_policies=total_policies,
                             assigned_policies=assigned_policies,
                             total_violations=total_violations,
                             pending_violations=pending_violations,
                             total_groups=total_groups,
                             total_group_members=total_group_members,
                             last_backup=last_backup,
                             recent_activities=recent_activities)
    except Exception as e:
        app.logger.error(f"Error loading dashboard: {str(e)}")
        flash('Error loading dashboard data', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/users/<int:user_id>/reset-password', methods=['POST'])
@login_required
@admin_required
def reset_user_password(user_id):
    try:
        user = User.query.get_or_404(user_id)
        
        # Generate a random password
        new_password = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation, k=12))
        
        # Hash the new password
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt())
        user.password_hash = hashed_password
        
        # Send email with new password
        msg = Message('Password Reset',
                     sender=app.config['MAIL_USERNAME'],
                     recipients=[user.email])
        msg.body = f'Your password has been reset. Your new password is: {new_password}\nPlease change this password after logging in.'
        mail.send(msg)
        
        db.session.commit()
        
        # Log the activity
        activity = SystemActivity(
            user_id=current_user.id,
            action='reset_password',
            details=f'Reset password for user: {user.username}'
        )
        db.session.add(activity)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Password reset successfully'})
    except Exception as e:
        db.session.rollback()
        print(f"Error resetting password: {str(e)}")  # Add debug logging
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/user-groups/<int:group_id>', methods=['PUT'])
@login_required
@admin_required
def update_user_group(group_id):
    try:
        group = UserGroup.query.get_or_404(group_id)
        data = request.form
        
        # Update group fields
        group.name = data.get('name', group.name)
        group.description = data.get('description', group.description)
        
        db.session.commit()
        
        # Log the activity
        activity = SystemActivity(
            user_id=current_user.id,
            action='update_group',
            details=f'Updated group: {group.name}'
        )
        db.session.add(activity)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Group updated successfully'})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating group: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/user-groups/<int:group_id>/members', methods=['GET'])
@login_required
@admin_required
def get_group_members(group_id):
    try:
        app.logger.debug(f"Fetching members for group {group_id}")
        group = UserGroup.query.get_or_404(group_id)
        app.logger.debug(f"Found group: {group.name}")
        
        # Get all users in the group
        members = group.users
        app.logger.debug(f"Group users: {[user.username for user in members]}")
        
        # Convert members to a list of dictionaries
        members_list = [{'id': user.id, 'username': user.username} for user in members]
        app.logger.debug(f"Members list: {members_list}")
        
        return jsonify({
            'success': True,
            'members': members_list
        })
    except Exception as e:
        app.logger.error(f"Error fetching group members: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/policies/<int:policy_id>/assignments')
@login_required
@admin_required
def get_policy_assignments(policy_id):
    try:
        policy = Policy.query.get_or_404(policy_id)
        
        # Get assigned groups
        assigned_groups = [{
            'id': group.id,
            'name': group.name,
            'description': group.description
        } for group in policy.groups]
        
        # Get assigned users through UserPolicyAssignment with explicit join condition
        assigned_users = [{
            'id': user.id,
            'username': user.username,
            'email': user.email
        } for user in User.query.join(
            UserPolicyAssignment,
            User.id == UserPolicyAssignment.user_id
        ).filter(UserPolicyAssignment.policy_id == policy_id).all()]
        
        return jsonify({
            'success': True,
            'groups': assigned_groups,
            'users': assigned_users
        })
        
    except Exception as e:
        app.logger.error(f"Error fetching policy assignments: {str(e)}")
        app.logger.error(f"Error type: {type(e)}")
        app.logger.error(f"Error args: {e.args}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': str(type(e).__name__),
            'error_details': str(e.args)
        }), 500

@app.route('/admin/reports/<int:report_id>', methods=['GET'])
@login_required
@admin_required
def get_report(report_id):
    try:
        report = Report.query.get_or_404(report_id)
        return jsonify({
            'success': True,
            'report': {
                'id': report.id,
                'name': report.name,
                'type': report.type,
                'schedule': report.schedule,
                'parameters': report.parameters,
                'is_active': report.is_active
            }
        })
    except Exception as e:
        app.logger.error(f"Error fetching report: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/reports/<int:report_id>', methods=['PUT'])
@login_required
@admin_required
def update_report(report_id):
    try:
        report = Report.query.get_or_404(report_id)
        data = request.get_json()
        
        # Validate required fields
        if not data.get('name'):
            return jsonify({'success': False, 'error': 'Report name is required'}), 400
            
        # Update report fields
        report.name = data.get('name', report.name)
        report.type = data.get('type', report.type)
        report.schedule = data.get('schedule', report.schedule)
        report.parameters = data.get('parameters', report.parameters)
        report.is_active = data.get('is_active', report.is_active)
        
        # Validate parameters based on report type
        if report.type == 'violation':
            if 'start_date' in report.parameters:
                try:
                    datetime.strptime(report.parameters['start_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid start date format. Use YYYY-MM-DD'}), 400
            if 'end_date' in report.parameters:
                try:
                    datetime.strptime(report.parameters['end_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid end date format. Use YYYY-MM-DD'}), 400
            if 'status' in report.parameters and report.parameters['status'] not in ['open', 'resolved', 'closed']:
                return jsonify({'success': False, 'error': 'Invalid status. Must be open, resolved, or closed'}), 400
            if 'policy_id' in report.parameters:
                try:
                    policy_id = int(report.parameters['policy_id'])
                    if not Policy.query.get(policy_id):
                        return jsonify({'success': False, 'error': 'Invalid policy ID'}), 400
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid policy ID format'}), 400

        elif report.type == 'compliance':
            if 'policy_type' in report.parameters and report.parameters['policy_type'] not in ['access', 'security', 'data']:
                return jsonify({'success': False, 'error': 'Invalid policy type'}), 400
            if 'is_active' in report.parameters:
                if not isinstance(report.parameters['is_active'], bool):
                    return jsonify({'success': False, 'error': 'is_active must be a boolean'}), 400

        elif report.type == 'audit':
            if 'start_date' in report.parameters:
                try:
                    datetime.strptime(report.parameters['start_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid start date format. Use YYYY-MM-DD'}), 400
            if 'end_date' in report.parameters:
                try:
                    datetime.strptime(report.parameters['end_date'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid end date format. Use YYYY-MM-DD'}), 400
            if 'action' in report.parameters and report.parameters['action'] not in ['create', 'update', 'delete', 'login', 'logout']:
                return jsonify({'success': False, 'error': 'Invalid action type'}), 400
            if 'user_id' in report.parameters:
                try:
                    user_id = int(report.parameters['user_id'])
                    if not User.query.get(user_id):
                        return jsonify({'success': False, 'error': 'Invalid user ID'}), 400
                except ValueError:
                    return jsonify({'success': False, 'error': 'Invalid user ID format'}), 400

        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Report updated successfully',
            'report': {
                'id': report.id,
                'name': report.name,
                'type': report.type,
                'schedule': report.schedule,
                'parameters': report.parameters,
                'is_active': report.is_active,
                'created_at': report.created_at.strftime('%Y-%m-%d %H:%M:%S')
            }
        })
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating report: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/reports/<int:report_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_report(report_id):
    try:
        report = Report.query.get_or_404(report_id)
        db.session.delete(report)
        db.session.commit()
        return jsonify({
            'success': True,
            'message': 'Report deleted successfully'
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting report: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True) 